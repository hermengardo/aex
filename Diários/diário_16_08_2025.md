# Diário (01/08/2025) - Detecção de AEX Similares

## Objetivo
- Identificar e agrupar atividades de extensão (AEX) similares ou duplicadas para limpeza dos dados.
- Detectar casos como "EU na USP" e outras atividades com descrições/títulos muito semelhantes.
- Preparar dados agregados para análise manual antes da remoção definitiva.

## Decisões
- **Agregação por NUSP do docente**
  - Supõe que itens repetidos são produzidos pelo mesmo docente responsável.
- **Threshold de similaridade**
  - Apenas itens que tem mais de 90% de similaridade cossenoidal
- **Corpus textual**
  - Embeddings gerados da combinação entre título e descrição da atividade.
- **Manter dados agregados**:
  - Os dados repetidos não foram eliminados automaticamente -> serão passados para uma revisão manual.

## Ambiente e dependências

| Dependência  | Uso                                            | Versão    |
| :----------: | :--------------------------------------------: | :-------: |
| `pandas`     | Manipulação de dados tabulares                 | 2.2.2         |
| `numpy`      | Operações numéricas e matrizes                 | 2.0.2         |
| `openai`     | API para geração de embeddings                 | 1.99.9         |
| `scikit-learn` | Cálculo de similaridade cossenoidal          | 1.6.1        |

## Scripts
- Ambiente: Google Colab (Python 3.11.13)
- **`Embeddings_+_Remoção_de_itens_repetidos.ipynb`**:
  - Carrega dados estruturados de AEX do arquivo `.parquet`
  - Constrói corpus textual combinando título e descrição
  - Gera embeddings usando modelo `text-embedding-3-large` da OpenAI
  - Calcula matriz de similaridade cossenoidal por docente (NUSP)
  - Identifica atividades similares acima do threshold (90%)
  - Agrega dados similares em formato tabular para revisão
  - Salva resultados em `repetidos.csv` e embeddings em `.parquet`

## Código
1. **Construção do corpus** e **Geração de embeddings**
  ```python
   class Processor:
      def __init__(self):
        self.key = CFG.API_KEY
        self.client = OpenAI(api_key=self.key)
        self.data = pd.read_parquet(CFG.PATH)
    
        self.run()
    
      @property
      def get_data(self):
        return self.data.copy()
    
      def run(self):
        self.build_corpus()
        self.get_embeddings()
    
      def build_corpus(self):
        self.data["Corpus"] = (
            self.data["Título da Atividade"].fillna(" ") + " " +
            self.data["Descrição da Atividade"].fillna(" ")
        ).str.strip()
    
        self.data["Corpus"] = self.data["Corpus"].str.replace("\n", " ")
    
      def get_embeddings(self):
         self.data["Embedding"] = self.data["Corpus"].progress_apply(
            lambda x: self.client.embeddings.create(
                model=CFG.MODEL,
                input=x
            ).data[0].embedding
        )
   ```

2. **Cálculo de similaridade**: Matriz de similaridade cossenoidal entre embeddings, agrupada por docente responsável.
3. **Agregação de similares**: Atividades similares são anexadas como colunas adicionais (`Similar_1_`, `Similar_2_`, etc.) à atividade raiz.
```python
  def find_similar(df, similarity_matrix, idx, threshold):
    similar_indices = np.where(similarity_matrix[idx] >= threshold)[0]
    similar_indices = similar_indices[similar_indices != idx]
    return df.loc[similar_indices, "AEX ID"].tolist()
  
  def cos_sim_by_nusp(df):
      dataframes = []
  
      for nusp in tqdm(df["Docente Responsável - NUSP"].unique()):
          temp = df[df["Docente Responsável - NUSP"] == nusp].copy()
          temp.reset_index(inplace=True, drop=True)
  
          if len(temp) == 1:
              temp["Similares"] = [[]]
          else:
              matrix = cosine_similarity(np.vstack(temp.Embedding.values))
              temp["Similares"] = temp.index.map(lambda idx: find_similar(temp, matrix, idx, CFG.THRESHOLD))
  
          dataframes.append(temp[["Título da Atividade", "AEX ID", "Docente Responsável - Nome", "Similares"]])
  
      return pd.concat(dataframes)
  
  def flatten_by_similarity(df, similars):
    '''
      Recebe um dataframe contendo AEX similares (similars)
      e o conjunto total de dados AEX (df)
      Retorna uma versão compactada de df com base na similaridade
    '''
    df = df.copy()
  
    added = []
    to_remove = []
  
    for key, row in similars.iterrows():
        IDs = row["Similares"]
        root = row["AEX ID"]
  
        if root not in added:
            added.append(root)
            for i, ID in enumerate(IDs):
                added.append(ID)
                to_remove.append(ID)
                similar_row = df.loc[df["AEX ID"] == ID, ["AEX ID", "Título da Atividade", "Descrição da Atividade"]]
  
                for col in similar_row.columns:
                    df.loc[df["AEX ID"] == root, f"Similar_{i+1}_{col}"] = similar_row.iloc[0][col] if not similar_row.empty else None
  
    df = df[~df["AEX ID"].isin(to_remove)]
  
    return df
  
  def run(df):
    df = df.copy()
    df = flatten_by_similarity(df, cos_sim_by_nusp(df))
  
    return df
```

## Estrutura de saída
- **Dados agregados**: Cada linha representa uma AEX raiz com suas similares organizadas em colunas.
- **Colunas principais**:
  - `(ROOT)`: Informações da atividade de referência
  - `Similar_N_*`: Título, descrição e ID das atividades similares
